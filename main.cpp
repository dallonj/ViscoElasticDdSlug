//
//  main.cpp
// 
//
//  Created by John Dallon on 8/7/23.
/*
 * Compile as cc -o a.out   The following code simulates the motion of an
 * aggregate of cells in  three dimensions.  The forces on each cell include
 * the viscous drag  forces due to other cells, viscous force due to the
 * substrate, active forces generated by a cell moving and passive forces due
 * to the visco-elastic properties of a cell. These forces are calculated and
 * the cells, assumed to be ellipsoids, move accordingly.  For more details
 * see   Palsson and Othmer, "A Model for Individual and Collective Cell
 * movement in Dictyostelium discoideum", PNAS 2000 is found in the file
 * cellmovedocumention and Dallon and
 * Othmer "How Cellular movement determines the collective force generated by
 * the Dictyostelium discoideum slug" in Journal of Theoretical Biology 2006
 * 231, pg 203-222.
 * Created by John Dallon and Erin Flowerday 2023
 * Units are microns and seconds and grams.
 */
//

// REMEMBER SLUG MOVES IN Y DIRECTIONS  

#include <stdlib.h>
#include <fstream>
#include "randomc.h"
#include "stocc.h"
#include <math.h>

#include <vector>
#include <sundials/sundials_math.h>    // def. math fcns, 'realtype'
#include <arkode/arkode_arkstep.h>    // prototypes for ARKStep fcts., consts
#include <nvector/nvector_serial.h>    // serial N_Vector type, fcts., macros
#include <sunmatrix/sunmatrix_dense.h>  // dense matrix type, fcts., macros
#include <sunlinsol/sunlinsol_dense.h>  // dense linear solver
#include <sunnonlinsol/sunnonlinsol_newton.h>      // Newton nonlinear solver
#include <sunnonlinsol/sunnonlinsol_fixedpoint.h>  // fixed-point nonlinear solver
#include <sundials/sundials_types.h>
#include <sundials/sundials_context.h>


//Additional things for kinsol
#include <kinsol/kinsol.h>
#include <cvode/cvode.h>
#include <sunlinsol/sunlinsol_spgmr.h>


#include <ceres/ceres.h>
#include <nlopt.h>


#include "cellclass.hpp"

#define ZERO SUN_RCONST(0.0)
#define ONE  SUN_RCONST(1.0)
#define TWO  SUN_RCONST(2.0)
#define PI  SUN_RCONST(3.141592653589793238463)

struct EllipsoidResidual {
  EllipsoidResidual(double x, double y, double z, double volume) : x_(x), y_(y), z_(z), volume_cell(volume) {}
  template <typename T>
  bool operator()(const T* const a, const T* const b, const T* const c, T* residual) const {
      residual[0] = x_*x_/(a[0]*a[0]) + y_*y_/(b[0]*b[0]) + z_*z_/(c[0]*c[0])-1.;
      residual[1] = a[0]*b[0]*c[0]/volume_cell -1.;
  return true;
  }
 private:
  const double x_;
  const double y_;
  const double z_;
  const double volume_cell;
};


// for nlopt
typedef struct {
    double volume_cell;
} my_constraint_data;

// defined for  ellipsoid_min_radii sove
typedef struct {
  double point1[3];
  double volume_cell;
} *UserDataMin;


 

using namespace std;

//solver for nlopt
//nlopt_algorithm ALGO=NLOPT_LD_MMA; // GOOD method of moving asymptote slowest (not by a lot)
//nlopt_algorithm ALGO=NLOPT_GD_STOGO;
//nlopt_algorithm ALGO=NLOPT_LD_TNEWTON_PRECOND_RESTART; bad cells shrink
//nlopt_algorithm ALGO=NLOPT_LD_TNEWTON;//bad
nlopt_algorithm ALGO=NLOPT_LD_SLSQP;  //GOOD  fastest
//nlopt_algorithm ALGO=NLOPT_LD_CCSAQ;//good  fast
//nlopt_algorithm ALGO=NLOPT_LN_SBPLX;//bad
//nlopt_algorithm ALGO=NLOPT_LN_PRAXIS;//bad
//nlopt_algorithm ALGO=NLOPT_LN_BOBYQA;//bad
//nlopt_algorithm ALGO=NLOPT_LN_COBYLA;//bad

double tfinal;
double print_interval;
double dt;

double lowerbound=4;// lower bound on cell radii 4.8
double upper=6;// upper bound ont cell radii 5.2

double cdx=10;
double cdy=10;
double cdz=10;

double area_cell;
double volume_cell_global;
double sum_radii_cell;
double overlap_factor=1;

// some variables needed for orient
double prot[3][3][ncells];
double tc[ncells];
double ts[ncells];
double kappa[ncells];


// Create and initialize the random number generator
int seed = (unsigned int) time(NULL);   //changed to unfixed seed
CRandomMersenne rg(seed);

// Create and initialize the random number generator
int seed2 = (unsigned int) time(NULL);   //changed to unfixed seed
StochasticLib1 rg1(seed2); 


//Cell parameters
int npst_cells;
double  cellvisc_spsp,cellvisc_spst,cellvisc_stst,cell_adhesion_normal_spsp,cell_adhesion_normal_spst,cell_adhesion_normal_stst,viscfactor,psp_param1a,psp_k1a,psp_mua,psp_param1b,psp_k1b,psp_mub,psp_param1c,psp_k1c,psp_muc,
psp_k2a,psp_k2b,psp_k2c,mindist,dia,psp_motive_force,psp_actb_force,psp_randforce;
double pst_param1a,pst_k1a,pst_mua,pst_param1b,pst_k1b,pst_mub,pst_param1c,pst_k1c,pst_muc,pst_k2a,pst_k2b,pst_k2c,pst_motive_force,pst_actb_force,pst_randforce;
double visc, turning_time, time_to_redirect, cone_angle_psp, cone_angle_pst;
char  filename[40];
char  efilename[40]="Erin";


double plate_height;

double skipz,skipx,skipy;

// table with different parameters for different cell types
double adhesion_drag[2][2];
double adhesion_normal[2][2];
double motive_force[2];

double vdot(double* aa, double* bb) {
    double dot;
    dot = 0;
    dot += aa[0] * bb[0];
    dot += aa[1] * bb[1];
    dot += aa[2] * bb[2];
    return dot;
}

// defined for exact ellipsoid sove
typedef struct {
  sunrealtype point1[3];
  sunrealtype point2[3];
  sunrealtype volume_cell;
} *UserData;

// defined for exact diffradiisolver
typedef struct {
  sunrealtype point1[3];
  sunrealtype point2[3];
  sunrealtype point3[3];
} *UserSpringData;

// User-supplied functions called by the solver
static int fe(sunrealtype t, N_Vector y, N_Vector ydot, void *user_data);
static int fi(sunrealtype t, N_Vector y, N_Vector ydot, void *user_data);
//static int Ji(sunrealtype t, N_Vector y, N_Vector fy, SUNMatrix J, void *user_data,
 //             N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);
//static int Jn(sunrealtype t, N_Vector y, N_Vector fy, SUNMatrix J, void *user_data,
//              N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);
static int MassMatrix(sunrealtype t, SUNMatrix M, void *user_data,
                      N_Vector tmp1, N_Vector tmp2, N_Vector tmp3);
// KINSOL user supplied functions
//static int exact_ellipsoid(N_Vector axis_radii, N_Vector f, void * user_data);
//nlopt function
double myconstraint(unsigned n, const double *x, double *grad, void *data);
//double ellipsoid_min_radii(const std::vector<double> &udata, const std::vector<double> &grad, void * user_data);
double ellipsoid_min_radii(unsigned n, const double *udata, double *grad, void *user_data);
double exact_ellipsoid(unsigned n, const double *udata, double *grad, void *user_data);
//CVODE user supplied function
static int DiffRadiiWPressure(sunrealtype t, N_Vector axis_radii, N_Vector f, void * user_data);

//Private Utility functions
static int check_retval(void *returnvalue, const char *funcname, int opt);

double surface (double dist, double d1, double d2);
void Overlap(Cell cell1, Cell cell2, double d[3], double v[3], double factor, double point[4]);
int find_nearest_cell(int i,double target[3],double center[3],double cone_angle,N_Vector y,  Cell * cell_loc);
void find_new_ellipsoid_size(int i,double a[3],double b[3],double c[3],double k[6],double fold[3],double ellisoid_info[ncells][ncells][3][4],double diam[3],double volume_local);
void change_cell_radii(Cell * cell_loc);
void evolve_cell_radii(Cell * cell_loc, double dt);


int main() {
    Cell * cell = new Cell[ncells]; // get memory for array of cells
    // Some local functions
    void initialize(Cell *cell);
    void set_direction(Cell *cell, double cone_angle_psp, double cone_angle_pst);
    void initialize_orient(Cell *cell);
    void orient(Cell *cell);
    int move_cellspc(void *arkode_mem, double time, N_Vector y,Cell *cell);
    void write_to_filed(ofstream *fout, Cell *cell);
    void write_to_file(ofstream *fout, Cell *cell);
    
    double T0=0;// initial time
    double time=T0;// current time
    initialize (cell);
    ofstream *foutc = new ofstream(filename);
    strcat(efilename, filename);
    ofstream *foutce = new ofstream(efilename);
    
    volume_cell_global=dia*dia*dia*.125;
    
    
    // general problem variables
    int order = 4;                    // order of accuracy for RK method
    sunbooleantype deduce = SUNFALSE;    // deduce fi after a nonlinear solve
    int retval;                    // reusable error-checking flag
    N_Vector y = NULL;             // empty vector for the computed solution
    void *arkode_mem = NULL;       // empty ARKStep memory structure
    SUNMatrix A = NULL;            // empty system matrix
    SUNMatrix M = NULL;            // empty mass matrix
    SUNLinearSolver LS = NULL;     // empty system linear solver object
    SUNLinearSolver MLS = NULL;    // empty mass linear solver object
    SUNNonlinearSolver NLS = NULL; // empty nonlinear solver object
   // sunindextype NEQ = 3*ncells+4*ncells;             // number of dependent vars.
     sunindextype NEQ = 3*ncells;             // number of dependent vars.
    //SUNDIALS SETUP
    // Create SUNDIALS context
     //    sundials::Context ctx;
    SUNContext ctx;
    SUNContext_Create(SUN_COMM_NULL,&ctx);

      // Create and initialize serial vector for the solution
      y = N_VNew_Serial(NEQ, ctx);
      if (check_retval((void *)y, "N_VNew_Serial", 0)) return 1;
      //DALLON DO this

      // Initialize ARKStep. Specify the right-hand side function(s) for
      // M(t) * y' = fe(t,y) + fi(t,y), the inital time T0, and the
      // initial dependent variable vector y.
        arkode_mem = ARKStepCreate(fe, fi, T0, y, ctx);
        if (check_retval((void *) arkode_mem, "ARKStepCreate", 0)) return 1;
    
    sunrealtype reltol = SUN_RCONST(1.e-9);
    sunrealtype abstol = SUN_RCONST(1.e-12);
    sunrealtype a11, a12, a21, a22, b1, b2;
    a11 = a12 = a21 = a22 = b1 = b2 = ZERO;

    // Tighten implicit solver to accommodate fixed step sizes
    retval = ARKStepSStolerances(arkode_mem, reltol, abstol);
    if (check_retval(&retval, "ARKStepSStolerances", 1)) return 1;
    retval = ARKStepResStolerance(arkode_mem, abstol);
    if (check_retval(&retval, "ARKStepResStolerance", 1)) return(1);
    retval = ARKStepSetMaxNumSteps(arkode_mem, 1000000);
    if (check_retval(&retval, "ARKStepSetMaxNumSteps", 1)) return(1);
   // retval = ARKStepSetJacEvalFrequency(arkode_mem, 1);
   // if (check_retval(&retval, "ARKStepSetJacEvalFrequency", 1)) return 1;
    retval = ARKStepSetLSetupFrequency(arkode_mem, 1);
    if (check_retval(&retval, "ARKStepSetLSetupFrequency", 1)) return 1;
    retval = ARKStepSetMaxNonlinIters(arkode_mem, 20);
    if (check_retval(&retval, "ARKStepSetMaxNonlinIters", 1)) return 1;



        // Initialize/attach nonlinear and linear solvers (if required)
            NLS = SUNNonlinSol_FixedPoint(y, 4, ctx);
            if (check_retval((void *)NLS, "SUNNonlinSol_FixedPoint", 0)) return 1;
            retval = ARKStepSetNonlinearSolver(arkode_mem, NLS);
            if (check_retval(&retval, "ARKStepSetNonlinearSolver", 1)) return(1);

    
    // Initialize/attach mass matrix solver
     M = SUNDenseMatrix(NEQ, NEQ, ctx);
     if (check_retval((void *)M, "SUNDenseMatrix", 0)) return 1;
     MLS = SUNLinSol_Dense(y, M, ctx);
     if (check_retval((void *)MLS, "SUNLinSol_Dense", 0)) return 1;
     retval = ARKStepSetMassLinearSolver(arkode_mem, MLS, M, SUNTRUE);
     if (check_retval(&retval, "ARKStepSetMassLinearSolver", 1)) return(1);
     retval = ARKStepSetMassFn(arkode_mem, MassMatrix);
     if (check_retval(&retval, "ARKStepSetMassFn", 1)) return(1);

     // Set desired solver order
     retval = ARKStepSetOrder(arkode_mem, order);
     if (check_retval(&retval, "ARKStepSetOrder", 1)) return 1;

     retval = ARKStepSetDeduceImplicitRhs(arkode_mem, deduce);
     if (check_retval(&retval, "ARKStepSetDeduceImplicitRhs", 1)) return 1;

     // Set the user data pointer
     retval = ARKStepSetUserData(arkode_mem, (void *) cell);
     if (check_retval(&retval, "ARKStepSetUserData", 1)) return 1;
    
    int print_step=print_interval/dt;// print every print_step
    int nsteps=int(tfinal/dt);
    cout<<" nstep "<<nsteps<<"\n";
    int ntime_to_redirect=time_to_redirect/dt;
    int norient=turning_time/dt;
    int norient_counter=0;
    
    *foutc<<ncells<<"\n";
    *foutc<<npst_cells<<"\n";
    *foutc<<nsteps/print_step<<"\n";
    // Main time loop
    for (int m=1; m<=nsteps; m++)
    {
        if((m-1)% ntime_to_redirect==0){
            std::cout<<"time "<<m*dt<<"\n";
            set_direction(cell,cone_angle_psp,cone_angle_pst);
            initialize_orient(cell);
            norient_counter=0;
	    if(m==1){
            // write at time 0
            *foutc<<0<<"\n";
            write_to_filed (foutc,cell);
            write_to_file (foutce,cell);
	    }
        }
        if((m-1)% ntime_to_redirect==0 || norient_counter<norient){
            orient(cell);
        }
        norient_counter=norient_counter+1;
   
        retval=move_cellspc(arkode_mem,time,y,cell);
            //    if(m==1)
        change_cell_radii(cell);
        
        
        evolve_cell_radii(cell,dt);
        
        if (m % print_step == 0)
            {
              *foutc<<dt*m<<"\n";
              write_to_filed (foutc,cell);
              write_to_file (foutce,cell);
                cout<<"Time = "<<time+dt<<"\n";
            }
        time=time+dt;
    }
    foutc->close();
    foutce->close();
    // Clean up and return
     ARKStepFree(&arkode_mem);       // Free integrator memory
     SUNLinSolFree(LS);              // free system linear solver
     SUNLinSolFree(MLS);             // free mass linear solver
     SUNNonlinSolFree(NLS);          // free nonlinear solver
     SUNMatDestroy(A);               // free system matrix
     SUNMatDestroy(M);               // free mass matrix
     N_VDestroy(y);                  // Free y vector
    // SUNContext_Free();
    return 0;
}

void
initialize (Cell *cell)
{
    void read_ifile(void);
    
    read_ifile();

    adhesion_drag[0][0]=cellvisc_spsp;
    adhesion_drag[0][1]=cellvisc_spst;
    adhesion_drag[1][0]=cellvisc_spst;
    adhesion_drag[1][1]=cellvisc_stst;
    
    adhesion_normal[0][0]=cell_adhesion_normal_spsp;
    adhesion_normal[0][1]=cell_adhesion_normal_spst;
    adhesion_normal[1][0]=cell_adhesion_normal_spst;
    adhesion_normal[1][1]=cell_adhesion_normal_stst;
    motive_force[0]=psp_motive_force;
    motive_force[1]=pst_motive_force;
    
        area_cell=PI*4.*dia*dia*.25; // in microns
	double randx=0;
	double randy=0;
	double randz=0;
	double randomAmp=1.;
	double xc[ncells];
	double yc[ncells];
	double zc[ncells];
	// 2 takes about 200 times for a 3x3x5 slug.
	int placement=2;//1 means npst_cells are placed in posterior of slug, 2 means 1 pst at center of posterior of slug, 3 randomly place in slug
        for (int k =0; k<ncy; k++){
	  for (int j =0; j<ncz; j++){
            for (int i =0; i<ncx; i++){
                int ii=i+j*ncx+k*ncx*ncz;
		randx=rg.Random()*randomAmp;
		randy=rg.Random()*randomAmp;
		randz=rg.Random()*randomAmp;		
                xc[ii] = (i+1)*cdx-5+randx;
                yc[ii] = (k+1)*cdy-5+randy;
                zc[ii] = (j+1)*cdz-5+randz;
	    }
	  }
	}
       	int ilist[ncells];
       	rg1.Shuffle(ilist,0,ncells);
	for(int ii=0; ii<ncells; ii++){
                int type;
                double randomdirx;
                double randomdiry;
                double randomdirz;
                //give a random direction to initialize the cell axes a
                randomdiry=rg.Random();// always in the quadrant 1 or 2
                randomdirx=2*(rg.Random()-.5);// always in the half plane containing the y axis
                randomdirz=2*(rg.Random()-.5);// always in the half plane containing the y axis
                double mag = std::sqrt(randomdirx*randomdirx+randomdiry*randomdiry+randomdirz*randomdirz);
                if (mag == 0.0) {
                    mag = 0.0000001;
                }
                randomdirx=randomdirx/mag;
                randomdiry=randomdiry/mag;
                randomdirz=randomdirz/mag;
                double randomdirxb;
                double randomdiryb;
                double randomdirzb;
                //give a random direction to initialize the cell axes b
                randomdirxb=2*(rg.Random()-.5);//
                randomdiryb=2*(rg.Random()-.5);//
                randomdirzb=2*(rg.Random()-.5);//
                mag = std::sqrt(randomdirxb*randomdirxb+randomdiryb*randomdiryb+randomdirzb*randomdirzb);
                if (mag == 0.0) {
                    mag = 0.0000001;
                }
                randomdirxb=randomdirxb/mag;
                randomdiryb=randomdiryb/mag;
                randomdirzb=randomdirzb/mag;
		// 1 pst in center of anterior portion of slug
		if(placement==2){
            int itmp=(ncz/2)*ncx+(ncx/2);
		if (ii==0){//pst cells
                    type=1;
                    cell[ii].initialize(type,xc[itmp],yc[itmp],zc[itmp],pst_k1a,pst_mua,pst_param1a,pst_k1b,pst_mub,pst_param1b,pst_k1c,pst_muc,pst_param1c,pst_k2a,pst_motive_force,pst_actb_force,pst_randforce,dia,randomdirx,randomdiry,randomdirz,randomdirxb,randomdiryb,randomdirzb);
                }
		else if (ii==itmp){
		   type=0;
                    cell[ii].initialize(type,xc[0],yc[0],zc[0],psp_k1a,psp_mua,psp_param1a,psp_k1b,psp_mub,psp_param1b,psp_k1c,psp_muc,psp_param1c,psp_k2a,psp_motive_force,psp_actb_force,psp_randforce,dia,randomdirx,randomdiry,randomdirz,randomdirxb,randomdiryb,randomdirzb);
                }
                else{//psp cells
                    type=0;
                    cell[ii].initialize(type,xc[ii],yc[ii],zc[ii],psp_k1a,psp_mua,psp_param1a,psp_k1b,psp_mub,psp_param1b,psp_k1c,psp_muc,psp_param1c,psp_k2a,psp_motive_force,psp_actb_force,psp_randforce,dia,randomdirx,randomdiry,randomdirz,randomdirxb,randomdiryb,randomdirzb);
                }
		}
	//pst in anterior portion of slug
		if(placement==1){
		if (ii<npst_cells){//pst cells
                    type=1;
                    cell[ii].initialize(type,xc[ii],yc[ii],zc[ii],pst_k1a,pst_mua,pst_param1a,pst_k1b,pst_mub,pst_param1b,pst_k1c,pst_muc,pst_param1c,pst_k2a,pst_motive_force,pst_actb_force,pst_randforce,dia,randomdirx,randomdiry,randomdirz,randomdirxb,randomdiryb,randomdirzb);
                }
                else{//psp cells
                    type=0;
                    cell[ii].initialize(type,xc[ii],yc[ii],zc[ii],psp_k1a,psp_mua,psp_param1a,psp_k1b,psp_mub,psp_param1b,psp_k1c,psp_muc,psp_param1c,psp_k2a,psp_motive_force,psp_actb_force,psp_randforce,dia,randomdirx,randomdiry,randomdirz,randomdirxb,randomdiryb,randomdirzb);
                }
		}
		// // pst cells randomly placed through the slug
		if(placement==3){
		if (ilist[ii]<npst_cells){//pst cells
                    type=1;
		    cell[ii].initialize(type,xc[ilist[ii]],yc[ilist[ii]],zc[ilist[ii]],pst_k1a,pst_mua,pst_param1a,pst_k1b,pst_mub,pst_param1b,pst_k1c,pst_muc,pst_param1c,pst_k2a,pst_motive_force,pst_actb_force,pst_randforce,dia,randomdirx,randomdiry,randomdirz,randomdirxb,randomdiryb,randomdirzb);
                }
                else{//psp cells
                    type=0;
		    cell[ii].initialize(type,xc[ilist[ii]],yc[ilist[ii]],zc[ilist[ii]],psp_k1a,psp_mua,psp_param1a,psp_k1b,psp_mub,psp_param1b,psp_k1c,psp_muc,psp_param1c,psp_k2a,psp_motive_force,psp_actb_force,psp_randforce,dia,randomdirx,randomdiry,randomdirz,randomdirxb,randomdiryb,randomdirzb);
                }
		}
            }// end ii loop x direction

}

void set_direction(Cell *cell, double cone_angle_psp, double cone_angle_pst){// picks a direction for each cell in a cone with half angle cone_angle about (0 1 0)
    for (int i = 0; i < ncells; i++) {
      double cone_angle=cone_angle_psp;
      if(cell[i].type==1)
	cone_angle=cone_angle_pst;
      
        double phi=rg.Random()*cone_angle; //inclination
        double theta=rg.Random()*2*PI; // azimuth
        cell[i].direction[0]=cos(theta)*sin(phi);// z and y interchanged to give direction along y axis
        cell[i].direction[2]=sin(theta)*sin(phi);
        cell[i].direction[1]=cos(phi);
    }
}

void initialize_orient(Cell *cell){
    double re1;
    int i, j;
    double tmporient;
    double tmpch[3];
    double tmpangle;
    for (i = 0; i < ncells; i++) {
        tmporient = vdot(cell[i].a.vector, cell[i].direction);
        if (fabs(1 - tmporient) < .00001)
        {
            kappa[i] = 0;
        }
        else if (fabs(1 + tmporient) < .00001)
        {
            for (j = 0; j <= 2; j++)
                cell[i].a.vector[j] = -cell[i].a.vector[j];// repolarize the cell
            kappa[i]=0;
        }
        else
        {                     /* directions are different */
            /*
             * find v=(a x dir) and rotate the axes about the
             * axis in the direction of v
             */
            tmpch[0] = cell[i].a.vector[1] * cell[i].direction[2] - cell[i].a.vector[2] * cell[i].direction[1];
            tmpch[1] = -cell[i].a.vector[0] * cell[i].direction[2] + cell[i].a.vector[2] * cell[i].direction[0];
            tmpch[2] = cell[i].a.vector[0] * cell[i].direction[1] - cell[i].a.vector[1] * cell[i].direction[0];
            
            /* normalize v=axdir */
            re1=
            sqrt((tmpch[0] * tmpch[0]) + (tmpch[1] * tmpch[1]) + (tmpch[2]* tmpch[2]));
            for (j = 0; j <= 2; j++) {
                tmpch[j]= tmpch[j] / re1;
            }
            /* determine the angle between a and dir */
            tmpangle = acos(tmporient);
            /* find the angle of rotation for each time step */
            tmpangle = tmpangle * dt / turning_time;
            /* set some commonly used values */
            tc[i] = cos(tmpangle);
            ts[i] = sin(tmpangle);
            
            prot[0][0][i] = tmpch[0] * tmpch[0] * (1 - tc[i]) + tc[i];
            prot[1][0][i] = tmpch[0] * tmpch[1] * (1 - tc[i]) + tmpch[2]* ts[i];
            prot[2][0][i] = tmpch[0] * tmpch[2] * (1 - tc[i]) - tmpch[1] * ts[i];
            prot[0][1][i] = tmpch[0] * tmpch[1] * (1 - tc[i]) - tmpch[2] * ts[i];
            prot[1][1][i] = tmpch[1] * tmpch[1] * (1 - tc[i]) + tc[i];
            prot[2][1][i] = tmpch[1] * tmpch[2] * (1 - tc[i]) + tmpch[0] * ts[i];
            prot[0][2][i] = tmpch[0] * tmpch[2] * (1 - tc[i]) + tmpch[1] * ts[i];
            prot[1][2][i] = tmpch[1] * tmpch[2] * (1 - tc[i]) - tmpch[0] * ts[i];
            prot[2][2][i] = tmpch[2] * tmpch[2] * (1 - tc[i]) + tc[i];
            // set the new direction indicator
            kappa[i] = 1.0;
        }
    }
}
void orient(Cell *cell){
    int i, j, ii;
    double tmprotate[3][3];
    
    
    for (i = 0; i < ncells; i++) {
        if(kappa[i]==1){
            //turn the axis
            for (j = 0; j <= 2; j++) {
                tmprotate[j][0] = cell[i].a.vector[j];
                tmprotate[j][1] = cell[i].b.vector[j];
                tmprotate[j][2] = cell[i].c.vector[j];
            }
            /* multiply prot*tmprotate to rotate the axis */
            for (j = 0; j <= 2; j++) {
                cell[i].a.vector[j] = 0.0;
                cell[i].b.vector[j] = 0.;
                cell[i].c.vector[j] = 0.;
                for (ii = 0; ii <= 2; ii++) {
                    cell[i].a.vector[j] += prot[j][ii][i] * tmprotate[ii][0];
                    cell[i].b.vector[j] += prot[j][ii] [i]* tmprotate[ii][1];
                    cell[i].c.vector[j] += prot[j][ii][i] * tmprotate[ii][2];
                }
            }
        }
        //The  entire cell is rotated so the axes maintain their length.
    }
}

int move_cellspc(void *arkode_mem,double time, N_Vector y, Cell *cell){//predict the forces on axis then move cells then repeat
    sunrealtype t = time;
    sunrealtype tout = time+dt;
    int ii;
    for(int itpred=1; itpred<2; itpred++){//
        //  predict_force
        
        // move the cells
        //load in the variables
        //load the cell centers into y
        for (int i=0; i<ncells; i++){
            ii=3*i;
            NV_Ith_S(y,ii) = cell[i].center[0];// x coordinate
            NV_Ith_S(y,ii+1) = cell[i].center[1];//y coordinate
            NV_Ith_S(y,ii+2) = cell[i].center[2];//z coordinate
        }
        // Find the contact area lagged to determine the mass matrix and some forces
        for (int i=0; i<ncells; i++){
            for (int j=i+1; j<ncells; j++){
                double d[3],v[3];
                double areatmp=0;
                double point[4];
                Overlap(cell[i],cell[j],d,v,1.2,point);
                if(d[0]<0){
                    areatmp=surface (d[0], d[1],d[2]);
                }
                cell[i].area[j]=areatmp/area_cell;
                cell[j].area[i]=areatmp/area_cell;
            }
            // find area with fluid
            cell[i].area[i]=0;
            for (int j=0; j<ncells; j++){
                if(j!=i)
                    cell[i].area[i]=cell[i].area[i]-cell[i].area[j];
            }
            cell[i].area[i]=1+cell[i].area[i];
            if (cell[i].area[i]<0)
                cell[i].area[i]=0;
        }
        //Solve one step
        // local variables
        int retval;
        
        // Reset ARKStep for this run
        retval = ARKStepReset(arkode_mem, time, y);
        if (check_retval(&retval, "ARKStepReset", 1)) return 1;
        retval = ARKStepSetFixedStep(arkode_mem, dt);
        if (check_retval(&retval, "ARKStepSetFixedStep", 1)) return 1;
        
        // call integrator and update output time
        retval = ARKStepEvolve(arkode_mem, tout, y, &t, ARK_ONE_STEP);
        if (check_retval(&retval, "ARKStepEvolve", 1)) return 1;
        
        //load the variables into cell
        //load y into cell centers
        if(retval==ARK_SUCCESS){
            for (int i=0; i<ncells; i++){
                ii=3*i;
                cell[i].center[0]= NV_Ith_S(y,ii);// x coordinate
                cell[i].center[1]= NV_Ith_S(y,ii+1);//y coordinate
                cell[i].center[2]= NV_Ith_S(y,ii+2);//z coordinate
            }
        }
    }
    time=time+dt;
    return 0;
}

// fi routine to compute the implicit portion of the ODE RHS.
static int fi(sunrealtype t, N_Vector y, N_Vector ydot, void *user_data)
{
//  UserData *udata = (UserData *) user_data;
 // const sunrealtype u = NV_Ith_S(y,0);
 // const sunrealtype v = NV_Ith_S(y,1);
  sunrealtype gcos, gsin, tmp1, tmp2;
    int ii;

  // fill in the RHS function:
  //   g*[ cos(t) sin(t)] * [rdot(t)/(2u)]
  //     [-sin(t) cos(t)]   [sdot(t)/(2v)]
  //gcos = (udata->M_timedep) ? udata->g*cos(t) : udata->g*cos(PI4);
  //gsin = (udata->M_timedep) ? udata->g*sin(t) : udata->g*sin(PI4);
 // tmp1 = rdot(t)/(TWO*u);
 // tmp2 = sdot(t)/(TWO*v);
    for (int i=0; i<ncells; i++){
        ii=3*i;
        NV_Ith_S(ydot,ii) = 0;// x coordinate
        NV_Ith_S(ydot,ii+1) = 0;//y coordinate
        NV_Ith_S(ydot,ii+2) =0;//z coordinate
    }

  // Return with success
  return 0;
}
// fe routine to compute the explicit portion of the ODE RHS.
static int fe(sunrealtype t, N_Vector y, N_Vector ydot, void *user_data)
{
//  UserData *udata = (UserData *) user_data;
    Cell *cell_loc =(Cell *) user_data;
  sunrealtype gcos, gsin, tmp1, tmp2, tmp3, tmp4;
    int ii,jj;
    double force_total[ncells][3]; // absolute value of all forces
    // initialize ydot and force_total
    for (int i=0; i<ncells; i++){
        ii=i*3;
        NV_Ith_S(ydot,ii) = 0;// x coordinate
        NV_Ith_S(ydot,ii+1) = 0;//y coordinate
        NV_Ith_S(ydot,ii+2) = 0;//z coordinate
        force_total[i][0]=0;
        force_total[i][1]=0;
        force_total[i][2]=0;
    }

    double alpha;//  alpha is the adhesiveness between cells

    // Find the contact area to determine the normal adhesive force Aij
//    for (int i=0; i<ncells; i++){
    for (int i=0; i<ncells; i++){
        ii=3*i;
        Cell cell1;
        cell1=cell_loc[i];
        cell1.center[0]=NV_Ith_S(y,ii);
        cell1.center[1]=NV_Ith_S(y,ii+1);
        cell1.center[2]=NV_Ith_S(y,ii+2);
        // for (int ke=0; maxneigh[celli]; ke++){
        //int j=neighborindex[ke];
        for (int j=i+1; j<ncells; j++){
                jj=3*j;
                double d[3],v[3];
                double areatmp=0;
                double fx=0;
                double fy=0;
                double fz=0;
                // store cells in temporary place and update variables to make implicit
                Cell cell2;
                cell2=cell_loc[j];
		alpha=1.;// 2 is too strong for 100 kspring 10 active force for more than 4 cells
                alpha=alpha*adhesion_normal[cell1.type][cell2.type];
                
                cell2.center[0]=NV_Ith_S(y,jj);
                cell2.center[1]=NV_Ith_S(y,jj+1);
                cell2.center[2]=NV_Ith_S(y,jj+2);
                double point[4];
                Overlap(cell1,cell2,d,v,1.4,point);
                if(d[0]<0){
		  if(d[0]>(-.1*d[1]-.1*d[2])){
                        areatmp=surface (d[0],d[1],d[2]);
                        fx=alpha*areatmp*v[0];
                        fy=alpha*areatmp*v[1];
                        fz=alpha*areatmp*v[2];
                    }
                    else if(d[0]>(-.3*d[1]-.3*d[2])){
		      double max_over_lap=(-.1*d[1]-.1*d[2]);
                        areatmp=surface(max_over_lap,d[1],d[2]);
                        double force = alpha*(d[0]+(.3*d[1]+.3*d[2]))*areatmp/((.2*d[1]+.2*d[2]));
			force=force*(d[0]+(.3*d[1]+.3*d[2]))/((.2*d[1]+.2*d[2]));// make decline quadratic
                        fx=force*v[0];
                        fy=force*v[1];
                        fz=force*v[2];
                    }
                    else{
                        fx=0;
                        fy=0;
                        fz=0;
                    }
                }
                
                force_total[i][0]+=abs(fx);
                force_total[i][1]+=abs(fy);
                force_total[i][2]+=abs(fz);
                
                force_total[j][0]+=abs(fx);
                force_total[j][1]+=abs(fy);
                force_total[j][2]+=abs(fz);
                
                NV_Ith_S(ydot,ii) += fx;
                NV_Ith_S(ydot,ii+1) += fy;
                NV_Ith_S(ydot,ii+2) += fz;
                
                NV_Ith_S(ydot,jj) += -fx;
                NV_Ith_S(ydot,jj+1) += -fy;
                NV_Ith_S(ydot,jj+2) += -fz;
        }// end j loop of cells
    }// end i loop of cells
    
    // Find motive force and traction force (opposite force to motive force)
    double out_reach_length=3*dia;  
    for (int i=0; i<ncells; i++){
        ii=3*i;
        double target[3], center[3];
        Cell cell1;
        cell1=cell_loc[i];
        cell1.center[0]=NV_Ith_S(y,ii);
        cell1.center[1]=NV_Ith_S(y,ii+1);
        cell1.center[2]=NV_Ith_S(y,ii+2);
        target[0]=out_reach_length*cell1.a.vector[0];
        target[1]=out_reach_length*cell1.a.vector[1];
        target[2]=out_reach_length*cell1.a.vector[2];
        center[0]=cell1.center[0];
        center[1]=cell1.center[1];
        center[2]=cell1.center[2];
        
        double fx=0;
        double fy=0;
        double fz=0;
        int j;
	double cone_angle=cos(cone_angle_psp);
	if(cell1.type==1)
	  cone_angle=cos(cone_angle_pst);
	
        j=find_nearest_cell(i,target,center,cone_angle, y, cell_loc);
        if(j>-1){
            jj=3*j;
            double direction[3],direction_length;
            direction[0]=NV_Ith_S(y,jj)-center[0];
            direction[1]=NV_Ith_S(y,jj+1)-center[1];
            direction[2]=NV_Ith_S(y,jj+2)-center[2];
            direction_length=sqrt(vdot(direction,direction));
            for (int k=0; k<3; k++){
                direction[k]=direction[k]/direction_length;
            }
            
            fx=0;
            fy=0;
            fz=0;
                fx=motive_force[cell1.type]*direction[0];
                fy=motive_force[cell1.type]*direction[1];
                fz=motive_force[cell1.type]*direction[2];
 
            force_total[i][0]+=abs(fx);
            force_total[i][1]+=abs(fy);
            force_total[i][2]+=abs(fz);
            
            force_total[j][0]+=abs(fx);
            force_total[j][1]+=abs(fy);
            force_total[j][2]+=abs(fz);
            
            NV_Ith_S(ydot,ii) += fx;
            NV_Ith_S(ydot,ii+1) += fy;
            NV_Ith_S(ydot,ii+2) += fz;
            
            NV_Ith_S(ydot,jj) += -fx;
            NV_Ith_S(ydot,jj+1) += -fy;
            NV_Ith_S(ydot,jj+2) += -fz;
        }
    }// end i cell loop
    
    // Find rhealogical forces and opposite
    double ellipsoid_info[ncells][ncells][3][4];
    for (int i=0; i<ncells; i++)
        for (int j=0; j<ncells; j++)
            for (int k=0; k<3; k++)
                for (int kk=0; kk<4; kk++)
                    ellipsoid_info[i][j][k][kk]=0;
     for (int i=0; i<ncells; i++)
       ellipsoid_info[i][0][2][0]=-1;
    int i_neigh;
    for (int i=0; i<ncells; i++){
        i_neigh=0;
        ii=3*i;
        double  center[3],d[3],v[3];
        Cell cell1;
        cell1=cell_loc[i];
        cell1.center[0]=NV_Ith_S(y,ii);
        cell1.center[1]=NV_Ith_S(y,ii+1);
        cell1.center[2]=NV_Ith_S(y,ii+2);
        
        center[0]=cell1.center[0];
        center[1]=cell1.center[1];
        center[2]=cell1.center[2];
        double fx=0;
        double fy=0;
        double fz=0;
        for (int j=0; j<ncells; j++){//FIX ALL THIS
            if(j!=i){
                jj=3*j;
                Cell cell2;
                cell2=cell_loc[j];
                cell2.center[0]=NV_Ith_S(y,jj);
                cell2.center[1]=NV_Ith_S(y,jj+1);
                cell2.center[2]=NV_Ith_S(y,jj+2);
                double point[4];
                Overlap(cell1,cell2,d,v,overlap_factor,point);
                if(d[0]<0){// cells overlap store in ellipsoid_info for future use
                    ellipsoid_info[i][i_neigh][0][0]=j;
                    ellipsoid_info[i][i_neigh][1][0]=point[3];
                    ellipsoid_info[i][i_neigh][0][1]=point[0];
                    ellipsoid_info[i][i_neigh][1][1]=point[1];
                    ellipsoid_info[i][i_neigh][2][1]=point[2];
                    ellipsoid_info[i][i_neigh][0][2]=d[0];
                    ellipsoid_info[i][i_neigh][1][2]=d[1];
                    ellipsoid_info[i][i_neigh][2][2]=d[2];
                    i_neigh=i_neigh+1;
                }
            }
        }//end j loop

	  if(i_neigh<1){
	    ellipsoid_info[i][0][2][0]=-1;
	  }
	  else{
	    ellipsoid_info[i][0][2][0]=i_neigh;
	  }

    }// end i cell loop
    for (int i=0; i<ncells; i++){
        if(ellipsoid_info[i][0][2][0]!=-1){
            double diam[3];
            diam[0]=cell_loc[i].a.length;
            diam[1]=cell_loc[i].b.length;
            diam[2]=cell_loc[i].c.length;
            double fold[3];
            double k[6];
            k[0]=cell_loc[i].a.kmaxwell_spring;
            k[1]=cell_loc[i].a.kspring;
            k[2]=cell_loc[i].b.kmaxwell_spring;
            k[3]=cell_loc[i].b.kspring;
            k[4]=cell_loc[i].c.kmaxwell_spring;
            k[5]=cell_loc[i].c.kspring;
            fold[0]=cell_loc[i].a.force_old;
            fold[1]=cell_loc[i].b.force_old;
            fold[2]=cell_loc[i].c.force_old;
            double tmpdiam[3];
            tmpdiam[0]=overlap_factor*diam[0];
            tmpdiam[1]=overlap_factor*diam[1];
            tmpdiam[2]=overlap_factor*diam[2];
            find_new_ellipsoid_size(i,cell_loc[i].a.vector,cell_loc[i].b.vector,cell_loc[i].c.vector, k,fold,ellipsoid_info,tmpdiam,overlap_factor*overlap_factor*overlap_factor*volume_cell_global);// length is the new diam for the ellipsoid
            // add forces to current cell
            ii=i*3;
            int n_neigh=round(ellipsoid_info[i][0][2][0]);// number of neighbors to put on current cell
	      NV_Ith_S(ydot,ii) += ellipsoid_info[i][n_neigh][0][3];
	      NV_Ith_S(ydot,ii+1) += ellipsoid_info[i][n_neigh][1][3];
	      NV_Ith_S(ydot,ii+2) += ellipsoid_info[i][n_neigh][2][3];
            //add forces to neighbor cells
            for (int jj=0; jj<n_neigh; jj++){
                int i_neigh=round(ellipsoid_info[i][jj][0][0])*3;
		    NV_Ith_S(ydot,i_neigh) += ellipsoid_info[i][jj][0][3];
		    NV_Ith_S(ydot,i_neigh+1) += ellipsoid_info[i][jj][1][3];
	            NV_Ith_S(ydot,i_neigh+2) += ellipsoid_info[i][jj][2][3];
            }
            // nucleus forces to push centers away
            for (int jj=0; jj<n_neigh; jj++){
                double center1[3],center2[3];
                center1[0]=cell_loc[i].center[0];
                center1[1]=cell_loc[i].center[1];
                center1[2]=cell_loc[i].center[2];
                int nn_neigh=round(ellipsoid_info[i][jj][0][0]);
                center2[0]=cell_loc[nn_neigh].center[0];
                center2[1]=cell_loc[nn_neigh].center[1];
                center2[2]=cell_loc[nn_neigh].center[2];
                double dist=0;
                double force[3];
                double mag;
                for (int k=0; k<3; k++)
                    dist+=(center1[k]-center2[k])*(center1[k]-center2[k]);
                if(dist<4){
		  mag=10*(exp(3*(1./dist-.25))-1.0);
                    double length;
                    force[0]=center1[0]-center2[0];
                    force[1]=center1[1]-center2[1];
                    force[2]=center1[2]-center2[2];
                    length=sqrt(vdot(force,force));
                    force[0]=force[0]*mag/length;
                    force[1]=force[1]*mag/length;
                    force[2]=force[2]*mag/length;
                    ii=i*3;
                    NV_Ith_S(ydot,ii) +=force[0];
                    NV_Ith_S(ydot,ii+1) +=force[1];
                    NV_Ith_S(ydot,ii+2) +=force[2];
                    //add forces to neighbor cells
                    int i_neigh=round(ellipsoid_info[i][jj][0][0])*3;
                    NV_Ith_S(ydot,i_neigh) += -force[0];
                    NV_Ith_S(ydot,i_neigh+1) += -force[1];
                    NV_Ith_S(ydot,i_neigh+2) += -force[2];
                }//end dist if
	    }//end forces pushing nucleus away
                
	}//end overlap cells if statement
    }// end i cell loop
    
    //FIND ydot in terms of a,b,c axis if positive and (force_total+ydot)/2 in a,bc, coordinates is greater then compress otherwise no compress
    // if negative (translation) and (-force_total+ydot)/2 is less then stretch
    // example for a
    // if(ydota>0 && (force_total+ydot)a/2 > ydota) compress with force ydota-(force_total+ydot)a/2 and translate ydota
    // else no compress and translate ydota
    //if(ydota<0 && (-force_total+ydot)a/2 <ydota) stretch  with force (force_total+ydot)a/2 and translate ydota
    // else no stretch and translate ydota.
    
    //LOWER BOUNDARY FORCE AND UPPER BOUNDARY FORCE
    for (int i=0; i<ncells; i++){
        double fxb,fxt,fzb,fzt;
        double center[3];
        double radius=5;
        double force=10;
       // double top=35;
        double top=55;
        //add forces for bottom boundary
        ii=i*3;
        center[0]=NV_Ith_S(y,ii);
        center[1]=NV_Ith_S(y,ii+1);
        center[2]=NV_Ith_S(y,ii+2);
        if(center[0]<radius && center[0]>0){
            fxb=force*(radius-center[0]);
        }
        else if (center[0]<0){
            fxb=radius*force;
        }
        else{
            fxb=0;
        }
        if(center[2]<radius && center[2]>0){
            fzb=force*(radius-center[2]);
        }
        else if (center[2]<0){
            fzb=radius*force;
        }
        else{
            fzb=0;
        }
        // add force for top
        if(center[0]>top-radius && center[0]<top){
            fxt=force*(top-radius-center[0]);
        }
        else if (center[0]>top){
            fxt=-radius*force;
        }
        else{
            fxt=0;
        }
        if(center[2]>top-radius && center[2]<top){
            fzt=force*(top-radius-center[2]);
        }
        else if (center[2]>top){
            fzt=-radius*force;
        }
        else{
            fzt=0;
        }
        
        NV_Ith_S(ydot,ii) += fxb+fxt;// x coordinate
        NV_Ith_S(ydot,ii+2) += fzb+fzt;// z coordinate
    }

  // Return with success
  return 0;
}

// Routine to compute the mass matrix multiplying y_t.
static int MassMatrix(sunrealtype t, SUNMatrix M, void *user_data,
                      N_Vector tmp1, N_Vector tmp2, N_Vector tmp3)
{
    Cell *cell_loc =(Cell *) user_data;
    int ii,jj;
    double mu_f=.1;// 10 times sphere of radius 5 in water at low Reynolds number  (dragforce=3 pi Diam 1cP *velocity)  originally 85 
    double mu_cell=20*mu_f;//     originally 1
    
    // initialize matrix as 0
    for (int i=0; i<3*ncells; i++)
        for (int j=0; j<3*ncells; j++)
            SM_ELEMENT_D(M, i, j) = ZERO;
    
    for (int i=0; i<ncells; i++){
        ii=3*i;
        SM_ELEMENT_D(M, ii, ii) =  SM_ELEMENT_D(M, ii, ii) + cell_loc[i].area[i]*mu_f;
        SM_ELEMENT_D(M, ii+1, ii+1) = SM_ELEMENT_D(M, ii+1, ii+1) + cell_loc[i].area[i]*mu_f;
        SM_ELEMENT_D(M, ii+2, ii+2) =  SM_ELEMENT_D(M, ii+2, ii+2) +  cell_loc[i].area[i]*mu_f;
        for (int j=0; j<ncells; j++){
            if(j!=i){
                jj=3*j;
                double mu_cellt=mu_cell*adhesion_drag[cell_loc[i].type][cell_loc[j].type];
                
                // drag due to other cells on ith cell
                
                SM_ELEMENT_D(M, ii, jj) = SM_ELEMENT_D(M, ii, jj) -cell_loc[i].area[j]*mu_cellt;
                SM_ELEMENT_D(M, ii+1, jj+1) = SM_ELEMENT_D(M, ii+1, jj+1)-cell_loc[i].area[j]*mu_cellt;
                SM_ELEMENT_D(M, ii+2, jj+2) = SM_ELEMENT_D(M, ii+2, jj+2)-cell_loc[i].area[j]*mu_cellt;
                
                SM_ELEMENT_D(M, ii, ii) = SM_ELEMENT_D(M, ii, ii) +cell_loc[i].area[j]*mu_cellt;
                SM_ELEMENT_D(M, ii+1, ii+1) = SM_ELEMENT_D(M, ii+1, ii+1) +cell_loc[i].area[j]*mu_cellt;
                SM_ELEMENT_D(M, ii+2, ii+2) = SM_ELEMENT_D(M, ii+2, ii+2)+cell_loc[i].area[j]*mu_cellt;
            }
        }
    }

  return 0;
}


/* This determines the surface contact area of the two cells assuming spheres of radius d1 and d2
 * dist is the distance between the membranes, d1 is  the distance from the center of one cell to its membrane, and
 *  d2 is the distance from another cell center to its membrane.
 */
double
surface (double dist, double d1, double d2)//need to test
{
  double fad, dd, h, r1sq, r2sq;
  dd = dist;
  r1sq = (d1) * (d1);
  r2sq = (d2) * (d2);
  h = d1 + dd + d2;
  fad = 0;
  /*This is the area of the region bounded by the circle of intersection of two sphere of radius d1 and d2. */
      fad =
    PI * (2. * h * h * r1sq + 2 * h * h * r2sq + 2 * r1sq * r2sq -
           h * h * h * h - r1sq * r1sq - r2sq * r2sq) / (4. * h * h);
  return (fad);
}

void Overlap(Cell cell1, Cell cell2, double d[3], double v[3], double factor, double point[4]){//d[0] is the overlap distance d[1] is distance from cell1 center to edge of cell 1 and d[2] is distance from cell2 center to edge of cell2 (for ellipsoids)  factor is the expansion factor used for cells point is needed for the deform routine.  point[3] is the length of vector_c1_c2.
    double vector_c1_c2[3];
    double re1[3];
    double re2[3];
    double len1,len2,vect_length,vect_lengthsq;
    int m;
    
    /* Find the vector between two cells and its length vect_length */
    vector_c1_c2[0] = cell2.center[0] - cell1.center[0];
    vector_c1_c2[1] = cell2.center[1] - cell1.center[1];
    vector_c1_c2[2] = cell2.center[2] - cell1.center[2];
    vect_lengthsq = vector_c1_c2[0] *vector_c1_c2[0] + vector_c1_c2[1] * vector_c1_c2[1] + vector_c1_c2[2] * vector_c1_c2[2];
    vect_length = sqrt (vect_lengthsq);
    v[0]=vector_c1_c2[0]/vect_length;
    v[1]=vector_c1_c2[1]/vect_length;
    v[2]=vector_c1_c2[2]/vect_length;

        /* Preliminary calculations to find d[1],d[1] and d[0]  */
        /* d[1], d[2] and d[0] are defined in a comment below */
        for (m = 0; m <= 2; m++)
      {            /* Initialize the vectors to
                   * zero */
        re1[m] = 0;
        re2[m] = 0;
      }
        /*
         * Find the projection of axis in the direction of the vector
         * between cells
         */
        for (m = 0; m <= 2; m++)
      {
        re1[0] += vector_c1_c2[m] * cell1.a.vector[m];
        re2[0] += -vector_c1_c2[m] * cell2.a.vector[m];
      }
        for (m = 0; m <= 2; m++)
      {
        re1[1] += vector_c1_c2[m] * cell1.b.vector[m];
        re2[1] += -vector_c1_c2[m] * cell2.b.vector[m];
      }
        for (m = 0; m <= 2; m++)
      {
        re1[2] += vector_c1_c2[m] * cell1.c.vector[m];
        re2[2] += -vector_c1_c2[m] * cell2.c.vector[m];
      }
    
    
        len1 =
      (re1[0] / (factor*cell1.a.length))*(re1[0] / (factor*cell1.a.length)) +  (re1[1] / (factor*cell1.b.length))*(re1[1] / (factor*cell1.b.length))  +
      (re1[2] / (factor*cell1.c.length))*(re1[2] / (factor*cell1.c.length));
        len1=len1/.25;  // correct since length is diameter
        len2 =
      (re2[0] / (factor*cell2.a.length))*(re2[0] / (factor*cell2.a.length)) + (re2[1] /(factor*cell2.b.length))*(re2[1] /(factor*cell2.b.length)) +
       (re2[2] / (factor*cell2.c.length))*(re2[2] / (factor*cell2.c.length));
        len2=len2/.25;
        /*
         * d[1] - the distance from the center of cell1 to the edge
         * in
         * the direction of vector_c1_c2 (the vector between the center of
         * cell
         * cell1 and cell2)
         * d[2] - the distance from the center of cell po1 to the edge
         * in
         * the direction of -vector_c1_c2 (the vector between the center of
         * cell
         * cell1 and cell2)
         * d[0] - the distance between cell1 and cell2 in the direction
         * of -vector_c1_c2, so ||r12||=vec_length=d[1]+d[2]+d[0] 
         */

        d[1] = sqrt (vect_lengthsq / len1);
        d[2] = sqrt (vect_lengthsq / len2);
        d[0] = vect_length - d[1] - d[2];
    for (m = 0; m <= 2; m++)
  {
      point[m]=re1[m];
  }
    point[3]=vect_length;
    
}

int find_nearest_cell(int i,double target[3],double center[3],double cone_angle, N_Vector y,  Cell * cell_loc){
    int jj, i_nearest;
    i_nearest=-1; // no cell meets criteria
    double min_length=100;
    for (int j=0; j<ncells; j++){//Look for cell closest to target but in correct cone
        if(i==j)continue; // skip the current cell
        jj=3*j;
        double d[3],v[3],target_normal[3];
       
        cell_loc[j].center[0]=NV_Ith_S(y,jj);
        cell_loc[j].center[1]=NV_Ith_S(y,jj+1);
        cell_loc[j].center[2]=NV_Ith_S(y,jj+2);
        
        // vector pointing to cellj center starting at cell1 center.
        d[0]=cell_loc[j].center[0]-center[0];
        d[1]=cell_loc[j].center[1]-center[1];
        d[2]=cell_loc[j].center[2]-center[2];
        
        double dlength,target_length;
        dlength=sqrt(vdot(d,d));
        target_length=sqrt(vdot(target,target));
        
        for (int k=0; k<3; k++){
            d[k]=d[k]/dlength;
            target_normal[k]=target[k]/target_length;
        }
        
        double tmp_angle=vdot(d,target_normal);
        
        if(cone_angle < tmp_angle){// cell is in the correct cone  cone_angle is the cosine of an angle
            if(dlength<min_length){
                min_length=dlength;
                i_nearest=j;
            }
        }
    }// end j find cell
    
    return i_nearest;

}

void find_new_ellipsoid_size(int i,double a[3],double b[3],double c[3],double kspring[6],double fold[3],double ellipsoid_info[ncells][ncells][3][4],double diam[3],double volume_local){
    //the forces on each cell are returned in ellipsoid_info[i][j][0][.][3]  x,y,z components for force pushing on cell j and
    // to balance forces  for j=i pushing on cell i is sum of forces over all j and opposite sign.
    
    //Erin-Initialise variables: determine the number of neighbouring cells and initialise arrays to store distances and projections
    int num_neigh=round(ellipsoid_info[i][0][2][0]);// number of neighbors
    double dlt[ncells][3], point[ncells][3], length[ncells],d[ncells][3];
    //Erin-extract interaction distances, overlap distance, center-to-edge distances for each neighbour
    for (int j=0; j<num_neigh; j++){
        for (int k=0; k<3; k++){
            point[j][k]=ellipsoid_info[i][j][k][1];
        }
        length[j]=ellipsoid_info[i][j][1][0];// length betwen cell i and cell j centers
        d[j][0]=ellipsoid_info[i][j][0][2];// overlap distance for cell i and cell j
        d[j][1]=ellipsoid_info[i][j][1][2];// distance to cell 1  center to cell 1 edge
        d[j][2]=ellipsoid_info[i][j][2][2];// distance to cell j center to cell j edge
    }
    //find projections onto axes
    if(num_neigh==1){//
        //Erin - Adjust the overlap distance based on specific conditions to ensure valid deformations
        if(abs(d[0][0])>=length[0])//if overlap is beyond cell center set to deform less
            d[0][1]=length[0]-.7*d[0][2];
        else{// otherwise set cell to deform half overlap distance
            d[0][1]=d[0][1]-abs(d[0][0]*.5);
        }
        // find the new point interms of axes coordinates
        //Erin - project the adjusted overlap distances onto the axes of the ellipsoid
        dlt[0][0]=d[0][1]*abs(point[0][0])/length[0];//a
        dlt[0][1]=d[0][1]*abs(point[0][1])/length[0];//b
        dlt[0][2]=d[0][1]*abs(point[0][2])/length[0];//c
        
        // use nlopt to minimize one cell impinging
        //Erin - use nlopt to minisize the objective function and find the new diameters of the ellipsoid
        UserDataMin data_points;
        data_points = (UserDataMin)malloc(sizeof *data_points);
        data_points->point1[0]=dlt[0][0];
        data_points->point1[1]=dlt[0][1];
        data_points->point1[2]=dlt[0][2];
        data_points->volume_cell=volume_local;
        sum_radii_cell=.5*diam[0]+.5*diam[1]+.5*diam[2];
        
        double lb[3] = {lowerbound,lowerbound,lowerbound}; /* lower bounds */
        double ub[3] = {upper,upper,upper}; /* upper bounds */
        nlopt_opt opt;
        opt = nlopt_create(ALGO, 3); /* algorithm and dimensionality */
        nlopt_set_lower_bounds(opt, lb);
        nlopt_set_upper_bounds(opt, ub);
        nlopt_set_min_objective(opt, ellipsoid_min_radii, data_points);
        my_constraint_data data = {volume_local};
        nlopt_add_equality_constraint(opt, myconstraint, &data, 1e-8);
        nlopt_set_xtol_rel(opt, 1e-4);
        double u[3] = { .5*diam[0],.5*diam[1],.5*diam[2] };  /* `*`some` `initial` `guess`*` */
        double minf; /* `*`the` `minimum` `objective` `value,` `upon` `return`*` */
        double new_diam[3];
        if (nlopt_optimize(opt, u, &minf) < 0) {
            printf("nlopt failed!\n");
            new_diam[0]=diam[0];
            new_diam[1]=diam[1];
            new_diam[2]=diam[2];
        }
        else {
            new_diam[0]=2*u[0];
            new_diam[1]=2*u[1];
            new_diam[2]=2*u[2];
        }
        nlopt_destroy(opt);
        free(data_points);
        // call routine to find pushing force
        double f[3];
        double sign_ap=1;
        double sign_bp=1;
        double sign_cp=1;
        if(point[0][0]<0)
            sign_ap=-1;
        if(point[0][1]<0)
            sign_bp=-1;
        if(point[0][2]<0)
            sign_cp=-1;
        f[0]=-(kspring[0]+kspring[1])*(new_diam[0]-diam[0]);
        f[1]=-(kspring[2]+kspring[3])*(new_diam[1]-diam[1]);
        f[2]=-(kspring[4]+kspring[5])*(new_diam[2]-diam[2]);
        ellipsoid_info[i][0][0][3]=f[0]*sign_ap*a[0]+f[1]*sign_bp*b[0]+f[2]*sign_cp*c[0];// x
        ellipsoid_info[i][0][1][3]=f[0]*sign_ap*a[1]+f[1]*sign_bp*b[1]+f[2]*sign_cp*c[1];// y
        ellipsoid_info[i][0][2][3]=f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2];// z
        //force on center cell
        ellipsoid_info[i][1][0][3]=-1.*(f[0]*sign_ap*a[0]+f[1]*sign_bp*b[0]+f[2]*sign_cp*c[0]);// x
        ellipsoid_info[i][1][1][3]=-1.*(f[0]*sign_ap*a[1]+f[1]*sign_bp*b[1]+f[2]*sign_cp*c[1]);// y
        ellipsoid_info[i][1][2][3]=-1.*(f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2]);// z
        //set diam to be the new diameters for the deformed ellipsoid
        diam[0]=new_diam[0];
        diam[1]=new_diam[1];
        diam[2]=new_diam[2];
        
        return;
    }// end block for 1 cell impinging
    else if (num_neigh==2){//
        double new_diam[3];
        for (int j=0; j<num_neigh; j++){
            d[j][0]=d[j][1]-abs(d[j][0]*.5);
            // find the new point interms of axes coordinates
            dlt[j][0]=d[j][0]*point[j][0]/length[j];//a
            dlt[j][1]=d[j][0]*point[j][1]/length[j];//b
            dlt[j][2]=d[j][0]*point[j][2]/length[j];//c
        }// end j loop over neighbor cells
        //solve system
        //abc-k=0
        // x1^2/a^2+y1^2/b^2+z1^2/c^2-1=0
        // x2^2/a^2+y2^2/b^2+z2^2/c^2-1=0
        //jac
        //  bc           ac           ab
        //  -2a^-3x1^2   -2b^-3y1^2  -2c^-3z1^2
        //  -2a^-3x2^2   -2b^-3y2^2  -2c^-3z2^2
        //
        // USE nlopt to find closest solution
        //
        UserData data_points;
        data_points = (UserData)malloc(sizeof *data_points);
        data_points->point1[0]=dlt[0][0];
        data_points->point1[1]=dlt[0][1];
        data_points->point1[2]=dlt[0][2];
        data_points->point2[0]=dlt[1][0];
        data_points->point2[1]=dlt[1][1];
        data_points->point2[2]=dlt[1][2];
        data_points->volume_cell=volume_local;
        
        double lb[3] = {lowerbound,lowerbound,lowerbound}; /* lower bounds */
        double ub[3] = {upper,upper,upper}; /* upper bounds */
        nlopt_opt opt;
        opt = nlopt_create(ALGO, 3); /* algorithm and dimensionality */
        nlopt_set_lower_bounds(opt, lb);
        nlopt_set_upper_bounds(opt, ub);
        nlopt_set_min_objective(opt, exact_ellipsoid, data_points);
        my_constraint_data data = {volume_local};
        nlopt_add_equality_constraint(opt, myconstraint, &data, 1e-8);
        nlopt_set_xtol_rel(opt, 1e-4);
        double u[3] = { .5*diam[0],.5*diam[1],.5*diam[2] };  /* `*`some` `initial` `guess`*` */
        double minf; /* `*`the` `minimum` `objective` `value,` `upon` `return`*` */
        if (nlopt_optimize(opt, u, &minf) < 0) {
            printf("nlopt failed!\n");
            new_diam[0]=diam[0];
            new_diam[1]=diam[1];
            new_diam[2]=diam[2];
        }
        else {
            new_diam[0]=2*u[0];
            new_diam[1]=2*u[1];
            new_diam[2]=2*u[2];
        }
        nlopt_destroy(opt);
        free(data_points);
        // call routine to find pushing force
        double f[3];
        double sign_ap=1;
        double sign_bp=1;
        double sign_cp=1;
        if(point[0][0]<0)
            sign_ap=-1;
        if(point[0][1]<0)
            sign_bp=-1;
        if(point[0][2]<0)
            sign_cp=-1;

        
        f[0]=-(kspring[0]+kspring[1])*(new_diam[0]-diam[0]);
        f[1]=-(kspring[2]+kspring[3])*(new_diam[1]-diam[1]);
        f[2]=-(kspring[4]+kspring[5])*(new_diam[2]-diam[2]);
         
        ellipsoid_info[i][0][0][3]=f[0]*sign_ap*a[0]+f[1]*sign_bp*b[0]+f[2]*sign_cp*c[0];// x
        ellipsoid_info[i][0][1][3]=f[0]*sign_ap*a[1]+f[1]*sign_bp*b[1]+f[2]*sign_cp*c[1];// y
        ellipsoid_info[i][0][2][3]=f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2];// z
        //force on center cell
        ellipsoid_info[i][2][0][3]=-1.*(f[0]*sign_ap*a[0]+f[1]*sign_bp*b[0]+f[2]*sign_cp*c[0]);// x
        ellipsoid_info[i][2][1][3]=-1.*(f[0]*sign_ap*a[1]+f[1]*sign_bp*b[1]+f[2]*sign_cp*c[1]);// y
        ellipsoid_info[i][2][2][3]=-1.*(f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2]);// z
        // for the second cell
        sign_ap=1;
        sign_bp=1;
        sign_cp=1;
        if(point[1][0]<0)
            sign_ap=-1;
        if(point[1][1]<0)
            sign_bp=-1;
        if(point[1][2]<0)
            sign_cp=-1;
        ellipsoid_info[i][1][0][3]=f[0]*sign_ap*a[0]+f[1]*sign_bp*b[0]+f[2]*sign_cp*c[0];// x
        ellipsoid_info[i][1][1][3]=f[0]*sign_ap*a[1]+f[1]*sign_bp*b[1]+f[2]*sign_cp*c[1];// y
        ellipsoid_info[i][1][2][3]=f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2];// z
        //force on center cell
        ellipsoid_info[i][2][0][3]+=-1.*(f[0]*sign_ap*a[0]+f[1]*sign_bp*b[0]+f[2]*sign_cp*c[0]);// x
        ellipsoid_info[i][2][1][3]+=-1.*(f[0]*sign_ap*a[1]+f[1]*sign_bp*b[1]+f[2]*sign_cp*c[1]);// y
        ellipsoid_info[i][2][2][3]+=-1.*(f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2]);// z
        //set diam to be the new diameters for the deformed ellipsoid
        diam[0]=new_diam[0];
        diam[1]=new_diam[1];
        diam[2]=new_diam[2];
        
         return;
        // call to solve 2 neighbors
       ellipsoid_info[i][num_neigh][2][3]=0*-1.*(f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2]);// z
    }// end block for 2 cells impinging
    else if(num_neigh>2){// least squares to find the best fit ellipsoid.
        // call to solve many neighbors
        for (int j=0; j<num_neigh; j++){
            d[j][0]=d[j][1]-abs(d[j][0]*.5);
            // find the new point interms of axes coordinates
            dlt[j][0]=d[j][0]*point[j][0]/length[j];//a
            dlt[j][1]=d[j][0]*point[j][1]/length[j];//b
            dlt[j][2]=d[j][0]*point[j][2]/length[j];//c
        }// end j loop over neighbor cells
        ceres::Problem problem;
        double aa=.5*diam[0];
        double bb=.5*diam[1];
        double cc=.5*diam[2];
        
        for (int j = 0; j < num_neigh; ++j) {
            problem.AddResidualBlock(new ceres::AutoDiffCostFunction<EllipsoidResidual,2,1,1,1>(new EllipsoidResidual(dlt[j][0],dlt[j][1],dlt[j][2],volume_local)),nullptr, &aa, &bb, &cc);
            
            
            problem.SetParameterLowerBound(&aa, 0, lowerbound);
            problem.SetParameterUpperBound(&aa, 0, upper);
            problem.SetParameterLowerBound(&bb, 0, lowerbound);
            problem.SetParameterUpperBound(&bb, 0, upper);
            problem.SetParameterLowerBound(&cc, 0, lowerbound);
            problem.SetParameterUpperBound(&cc, 0, upper);
        }
            
            ceres::Solver::Options options;
            options.max_num_iterations = 25;
            options.linear_solver_type = ceres::DENSE_QR;
            options.minimizer_progress_to_stdout = true;
            options.logging_type = ceres::SILENT;
            ceres::Solver::Summary summary;
            ceres::Solve(options, &problem, &summary);
            
        double new_diam[3];
        new_diam[0]=2.*aa;
        new_diam[1]=2.*bb;
        new_diam[2]=2.*cc;
        
        // add forces to and from impinging cells
        //Erin - calculate the forces based on the new diameters and the spring
        double f[3];
         f[0]=-(kspring[0]+kspring[1])*(new_diam[0]-diam[0]);
        f[1]=-(kspring[2]+kspring[3])*(new_diam[1]-diam[1]);
        f[2]=-(kspring[4]+kspring[5])*(new_diam[2]-diam[2]);
        ellipsoid_info[i][num_neigh][0][3]=0;
        ellipsoid_info[i][num_neigh][1][3]=0;
        ellipsoid_info[i][num_neigh][2][3]=0;
        for (int j = 0; j < num_neigh; ++j) {
            double sign_ap=1;
            double sign_bp=1;
            double sign_cp=1;
            if(point[j][0]<0)
                sign_ap=-1;
            if(point[j][1]<0)
                sign_bp=-1;
            if(point[j][2]<0)
                sign_cp=-1;
            //Erin - update the ellipsoid information with the calculated forces
            ellipsoid_info[i][j][0][3]=f[0]*sign_ap*a[0]+f[1]*sign_bp*b[0]+f[2]*sign_cp*c[0];// x
            ellipsoid_info[i][j][1][3]=f[0]*sign_ap*a[1]+f[1]*sign_bp*b[1]+f[2]*sign_cp*c[1];// y
            ellipsoid_info[i][j][2][3]=f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2];// z
            //force on center cell
            ellipsoid_info[i][num_neigh][0][3]+=-1.*(f[0]*sign_ap*a[0]+f[1]*sign_bp*b[0]+f[2]*sign_cp*c[0]);// x
            ellipsoid_info[i][num_neigh][1][3]+=-1.*(f[0]*sign_ap*a[1]+f[1]*sign_bp*b[1]+f[2]*sign_cp*c[1]);// y
            ellipsoid_info[i][num_neigh][2][3]+=-1.*(f[0]*sign_ap*a[2]+f[1]*sign_bp*b[2]+f[2]*sign_cp*c[2]);// z
            
        }
        diam[0]=new_diam[0];
        diam[1]=new_diam[1];
        diam[2]=new_diam[2];
            return;
        }// end block for many cells impinging
    }
// Evolve cell shape  axes decouples
void evolve_cell_radii(Cell * cell_loc, double dt){
      SUNContext sunctx;
      sunrealtype dx, dy, reltol, abstol, t, tout, umax;
      N_Vector u;
      UserSpringData data;
      SUNMatrix A;
      SUNLinearSolver LS;
      SUNNonlinearSolver NLS;
      void *cvode_mem;
      int iout, retval;
      long int nst;

      u = NULL;
      data = NULL;
      A = NULL;
      LS = NULL;
      NLS = NULL;
      cvode_mem = NULL;
    /* Create the SUNDIALS context */
      //SUNContext sunctx;
      retval = SUNContext_Create(SUN_COMM_NULL, &sunctx);
      if(check_retval(&retval, "SUNContext_Create", 1)) return;

     /* Create a serial vector */

     u = N_VNew_Serial(3, sunctx);  /* Allocate u vector */
     if(check_retval((void*)u, "N_VNew_Serial", 0)) return;

     reltol = ZERO;  /* Set the tolerances */
     abstol = 1.e-5;
    
    /* Call CVodeCreate to create the solver memory and specify the
     * Backward Differentiation Formula */
    cvode_mem = CVodeCreate(CV_BDF, sunctx);
    if(check_retval((void *)cvode_mem, "CVodeCreate", 0)) return;
    double T0=0;
      retval = CVodeInit(cvode_mem, DiffRadiiWPressure, T0, u);
      if(check_retval(&retval, "CVodeInit", 1)) return;

    /* create fixed point nonlinear solver object */

    /* create Newton nonlinear solver object */
       NLS = SUNNonlinSol_Newton(u, sunctx);
       if(check_retval((void *)NLS, "SUNNonlinSol_Newton", 0)) return;

      /* attach nonlinear solver object to CVode */
      retval = CVodeSetNonlinearSolver(cvode_mem, NLS);
      if(check_retval(&retval, "CVodeSetNonlinearSolver", 1)) return;
        LS = SUNLinSol_SPGMR(u, SUN_PREC_NONE, 0, sunctx);
         if (check_retval((void *)LS, "SUNLinSol_SPGMR", 0)) return;
         retval = CVodeSetLinearSolver(cvode_mem, LS, NULL);
         if (check_retval(&retval, "CVodeSetLinearSolver", 1)) return;


     data = (UserSpringData) malloc(sizeof *data);  /* Allocate data memory */
     if(check_retval((void *)data, "malloc", 2)) return;
    for (int i=0; i<ncells; i++){
        data->point1[0]=cell_loc[i].a.kmaxwell_spring;
        data->point1[1]=cell_loc[i].a.kspring;
        data->point1[2]=cell_loc[i].a.mu;
        data->point2[0]=cell_loc[i].b.kmaxwell_spring;
        data->point2[1]=cell_loc[i].b.kspring;
        data->point2[2]=cell_loc[i].b.mu;
        data->point3[0]=cell_loc[i].c.kmaxwell_spring;
        data->point3[1]=cell_loc[i].c.kspring;
        data->point3[2]=cell_loc[i].c.mu;
        
        NV_Ith_S(u,0)=cell_loc[i].a.length-dia;
        NV_Ith_S(u,1)=cell_loc[i].b.length-dia;
        NV_Ith_S(u,2)=cell_loc[i].c.length-dia;
        
          /* Call CVodeInit to initialize the integrator memory and specify the
           * user's right hand side function in u'=f(t,u), the inital time T0, and
           * the initial dependent variable vector u. */
        double T0=0;
          retval = CVodeReInit(cvode_mem,T0, u);
          if(check_retval(&retval, "CVodeInit", 1)) return;

        /* Call CVodeSStolerances to specify the scalar relative tolerance
          * and scalar absolute tolerance */
         retval = CVodeSStolerances(cvode_mem, reltol, abstol);
         if (check_retval(&retval, "CVodeSStolerances", 1)) return;

         /* Set the pointer to user-defined data */
         retval = CVodeSetUserData(cvode_mem, data);
         if(check_retval(&retval, "CVodeSetUserData", 1)) return;
        double tout=dt;
        double t;
        retval = CVode(cvode_mem, tout, u, &t, CV_NORMAL);
        if(check_retval(&retval, "CVode", 1)) break;
        
        cell_loc[i].a.length=NV_Ith_S(u,0)+dia;
        cell_loc[i].b.length=NV_Ith_S(u,1)+dia;
        cell_loc[i].c.length=NV_Ith_S(u,2)+dia;
        
    }
    N_VDestroy(u);          /* Free the u vector */
    CVodeFree(&cvode_mem);  /* Free the integrator memory */
    SUNLinSolFree(LS);      /* Free linear solver memory  */
    SUNNonlinSolFree(NLS);      /* Free nonlinear solver memory  */
    SUNMatDestroy(A);       /* Free the matrix memory     */
    SUNContext_Free(&sunctx);
    free(data);             /* Free the user data */
}

// Change cell shape
void change_cell_radii(Cell * cell_loc){
    double ellipsoid_info[ncells][ncells][3][4];
    for (int i=0; i<ncells; i++)
        for (int j=0; j<ncells; j++)
            for (int k=0; k<3; k++)
                for (int kk=0; kk<4; kk++)
                    ellipsoid_info[i][j][k][kk]=-1;
    int i_neigh;
    for (int i=0; i<ncells; i++){
        i_neigh=0;
        double  center[3],d[3],v[3];
        Cell cell1;
        cell1=cell_loc[i];
        center[0]=cell1.center[0];
        center[1]=cell1.center[1];
        center[2]=cell1.center[2];
        double fx=0;
        double fy=0;
        double fz=0;
        for (int j=0; j<ncells; j++){
            if(j!=i){
            Cell cell2;
            cell2=cell_loc[j];
            double point[4];
            Overlap(cell1,cell2,d,v,overlap_factor,point);
                if(d[0]<0){// cells overlap store in ellipsoid_info for future use
                    ellipsoid_info[i][i_neigh][0][0]=j;
                    ellipsoid_info[i][i_neigh][1][0]=point[3];
                    ellipsoid_info[i][i_neigh][0][1]=point[0];
                    ellipsoid_info[i][i_neigh][1][1]=point[1];
                    ellipsoid_info[i][i_neigh][2][1]=point[2];
                    ellipsoid_info[i][i_neigh][0][2]=d[0];
                    ellipsoid_info[i][i_neigh][1][2]=d[1];
                    ellipsoid_info[i][i_neigh][2][2]=d[2];
                    i_neigh=i_neigh+1;
                }
            }
        }//end j loop
        ellipsoid_info[i][0][2][0]=i_neigh;
    }// end i cell loop
    for (int i=0; i<ncells; i++){
        if(ellipsoid_info[i][0][2][0]!=-1){
            double diam[3];
            diam[0]=cell_loc[i].a.length;
            diam[1]=cell_loc[i].b.length;
            diam[2]=cell_loc[i].c.length;
            double fold[3];
            double k[6];
            k[0]=cell_loc[i].a.kmaxwell_spring;
            k[1]=cell_loc[i].a.kspring;
            k[2]=cell_loc[i].b.kmaxwell_spring;
            k[3]=cell_loc[i].b.kspring;
            k[4]=cell_loc[i].c.kmaxwell_spring;
            k[5]=cell_loc[i].c.kspring;
            fold[0]=cell_loc[i].a.force_old;
            fold[1]=cell_loc[i].b.force_old;
            fold[2]=cell_loc[i].c.force_old;
            double tmpdiam[3];
            tmpdiam[0]=overlap_factor*diam[0];
            tmpdiam[1]=overlap_factor*diam[1];
            tmpdiam[2]=overlap_factor*diam[2];
            find_new_ellipsoid_size(i,cell_loc[i].a.vector,cell_loc[i].b.vector,cell_loc[i].c.vector, k,fold,ellipsoid_info,tmpdiam,overlap_factor*overlap_factor*overlap_factor*volume_cell_global);// length is the new diam for the ellipsoid
            // add forces to current cell
            cell_loc[i].a.length=1*tmpdiam[0]/overlap_factor;
            cell_loc[i].b.length=1*tmpdiam[1]/overlap_factor;
            cell_loc[i].c.length=1*tmpdiam[2]/overlap_factor;
              
        }
        }// end i cell loop
}

//Nearest neigbor
    
//KD initialization



void write_to_file(ofstream* fout, Cell* cell) {
    if (!fout || !cell) {
        cerr << "Either fout or cell is a null pointer" << endl;
        return;
    }
    *fout << "a length, b length, c length, type, x centre, y centre, z centre, a vector, b vector, c vector, ncells" << endl;
    for (int i = 0; i < ncells; i++) {
        *fout << cell[i].a.length << "," << cell[i].b.length << ","
<< cell[i].c.length <<
            "," << cell[i].type <<
            "," << cell[i].center[0] << "," << cell[i].center[1] <<
"," << cell[i].center[2] <<
            "," << cell[i].a.vector[0] << "," << cell[i].a.vector[1]
<< "," << cell[i].a.vector[2] <<
            "," << cell[i].b.vector[0] << "," << cell[i].b.vector[1]
<< "," << cell[i].b.vector[2] <<
            "," << cell[i].c.vector[0] << "," << cell[i].c.vector[1]
<< "," << cell[i].c.vector[2] <<
        ",";
            //include pressure
    }
    *fout << ncells << endl;
}

void write_to_filed(ofstream *fout, Cell *cell){
    for (int i=0; i<ncells; i++){
        *fout <<cell[i].center[0]<<" "<<cell[i].center[1]<<" "<<cell[i].center[2]<<"\n";
        *fout <<cell[i].a.vector[0]<<" "<<cell[i].a.vector[1]<<" "<<cell[i].a.vector[2]<<"\n";
        *fout <<cell[i].b.vector[0]<<" "<<cell[i].b.vector[1]<<" "<<cell[i].b.vector[2]<<"\n";
        *fout <<cell[i].c.vector[0]<<" "<<cell[i].c.vector[1]<<" "<<cell[i].c.vector[2]<<"\n";
        *fout<<cell[i].a.length<<" "<<cell[i].b.length<<" "<<cell[i].c.length<<"\n";
        *fout<<cell[i].direction[0]<<" "<<cell[i].direction[1]<<" "<<cell[i].direction[2]<<"\n";
	*fout<<cell[i].type<<"\n";
    }
    
}


void one_cell_overlap()
{
}

void two_cell_overlap()
{
}

void many_cell_overlap()
{
}


void
read_ifile (void)
{
  FILE *fp;
  char string[150];
  int i;

  fp = fopen ("/Users/dallon/work/Erin/Graduate/slug/ErinCode/ifile.dat", "r");
  if (fp == (FILE *) NULL)
    printf ("error opening ifile \n");
  i = fscanf (fp, "%[^=]=%d\n", string, &npst_cells);
  i = fscanf (fp, "%[^=]=%lf\n", string, &tfinal);
  i = fscanf (fp, "%[^=]=%lf\n", string, &print_interval);
  i = fscanf (fp, "%[^=]=%lf\n", string, &dt);
  i = fscanf (fp, "%[^=]=%lf\n", string, &cellvisc_spsp);
  i = fscanf (fp, "%[^=]=%lf\n", string, &cellvisc_spst);
  i = fscanf (fp, "%[^=]=%lf\n", string, &cellvisc_stst);
  i = fscanf (fp, "%[^=]=%lf\n", string, &cell_adhesion_normal_spsp);
  i = fscanf (fp, "%[^=]=%lf\n", string, &cell_adhesion_normal_spst);
  i = fscanf (fp, "%[^=]=%lf\n", string, &cell_adhesion_normal_stst);
  i = fscanf (fp, "%[^=]=%lf\n", string, &visc);
  i = fscanf (fp, "%[^=]=%lf\n", string, &viscfactor);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_param1a);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_k2a);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_k1a);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_mua);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_param1b);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_k2b);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_k1b);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_mub);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_param1c);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_k2c);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_k1c);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_muc);
  i = fscanf (fp, "%[^=]=%lf\n", string, &mindist);
  i = fscanf (fp, "%[^=]=%lf\n", string, &dia);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_motive_force);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_actb_force);
  i = fscanf (fp, "%[^=]=%lf\n", string, &psp_randforce);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_param1a);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_k2a);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_k1a);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_mua);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_param1b);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_k2b);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_k1b);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_mub);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_param1c);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_k2c);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_k1c);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_muc);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_motive_force);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_actb_force);
  i = fscanf (fp, "%[^=]=%lf\n", string, &pst_randforce);
  i = fscanf (fp, "%[^=]=%lf\n", string, &skipx);
  i = fscanf (fp, "%[^=]=%lf\n", string, &skipy);
  i = fscanf (fp, "%[^=]=%lf\n", string, &skipz);
  i = fscanf (fp, "%[^=]=%lf\n", string, &plate_height);
  i = fscanf (fp, "%[^=]=%lf\n", string, &turning_time);
  i = fscanf (fp, "%[^=]=%lf\n", string, &time_to_redirect);
  i = fscanf (fp, "%[^=]=%lf\n", string, &cone_angle_psp);
  i = fscanf (fp, "%[^=]=%lf\n", string, &cone_angle_pst);
  cone_angle_psp=cone_angle_psp*PI/180.;// make cone_angle radians
  cone_angle_pst=cone_angle_pst*PI/180.;// make cone_angle radians  
    i = fscanf (fp, "%[^=]=%s\n", string, filename);

  fclose (fp);
}


/* Check function return value...
    opt == 0 means SUNDIALS function allocates memory so check if
             returned NULL pointer
    opt == 1 means SUNDIALS function returns a retval so check if
             retval < 0
    opt == 2 means function allocates memory so check if returned
             NULL pointer
*/
static int check_retval(void *returnvalue, const char *funcname, int opt)
{
  int *retval;

  // Check if SUNDIALS function returned NULL pointer - no memory allocated
  if (opt == 0 && returnvalue == NULL) {
    fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
            funcname);
    return 1; }

  // Check if retval < 0
  else if (opt == 1) {
    retval = (int *) returnvalue;
    if (*retval < 0) {
      fprintf(stderr, "\nSUNDIALS_ERROR: %s() failed with retval = %d\n\n",
              funcname, *retval);
      return 1; }}

  // Check if function returned NULL pointer - no memory allocated
  else if (opt == 2 && returnvalue == NULL) {
    fprintf(stderr, "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
            funcname);
    return 1; }

  return 0;
}
// nlopt for 1 cell impinging.
//double ellipsoid_min_radii(const std::vector<double> &udata, const std::vector<double> &grad, void * user_data)
double ellipsoid_min_radii(unsigned n, const double *udata, double *grad, void *user_data)
{
    double fdata[2];
    double a, au, al ,b, bu, bl, c, cu,cl ,x,y,z,volume_cell, sum_radii;
    double x1[3];
    double scale=1.;
    UserDataMin data;
    data=(UserDataMin) user_data;
    x1[0] = data->point1[0];
    x1[1] = data->point1[1];
    x1[2] = data->point1[2];
    volume_cell = data->volume_cell;
    sum_radii=sum_radii_cell;
    
    a=udata[0];
    b=udata[1];
    c=udata[2];

    x=x1[0];//point1 x coordinate
    y=x1[1];//point1 y coordinate
    z=x1[2];//point1 z coordinate
    
    fdata[0]=scale*(x*x/(a*a)+y*y/(b*b)+z*z/(c*c)-1.);
    fdata[1]=(a+b+c)/sum_radii-1;
    
    if(grad){
        grad[0]=2*fdata[0]*(-2*x*x/(a*a*a)*scale)+2*fdata[1]/sum_radii;
        grad[1]=2*fdata[0]*(-2*y*y/(b*b*b)*scale)+2*fdata[1]/sum_radii;
        grad[2]=2*fdata[0]*(-2*z*z/(c*c*c)*scale)+2*fdata[1]/sum_radii;
    }
    return fdata[0]*fdata[0]+fdata[1]*fdata[1];

}

double myconstraint(unsigned n, const double *x, double *grad, void *data)
{
    my_constraint_data *d = (my_constraint_data *) data;
    double volume_cell = d->volume_cell;
    if (grad) {
        grad[0] = x[1]*x[2]/volume_cell;
        grad[1] = x[0]*x[2]/volume_cell;
        grad[2] = x[1]*x[0]/volume_cell;
    }
    return (x[0] * x[1] *x[2])/volume_cell -1;
 }


//static int exact_ellipsoid(N_Vector axis_radii, N_Vector f, void * user_data)
// nlopt for 2 cell impinging.
double exact_ellipsoid(unsigned n, const double *udata, double *grad, void *user_data){
    double fdata[2];
    double a, au, al ,b, bu, bl, c, cu,cl ,x,y,z,volume_cell;
    double *x1, *x2;
    UserData data;
    
    data=(UserData)user_data;
    x1 = data->point1;
    x2 = data->point2;
    volume_cell = data->volume_cell;
    
    a=udata[0];
    b=udata[1];
    c=udata[2];
    
    x=x1[0];//point1 x coordinate
    y=x1[1];//point1 y coordinate
    z=x1[2];//point1 z coordinate
    
    fdata[0]=x*x/(a*a)+y*y/(b*b)+z*z/(c*c)-1.;
    
    x=x2[0];//point2 x coordinate
    y=x2[1];//point2 y coordinate
    z=x2[2];//point2 z coordinate
    
    fdata[1]=x*x/(a*a)+y*y/(b*b)+z*z/(c*c)-1.;
    
    if(grad){
        grad[0]=2*fdata[1]*(-2*x*x/(a*a*a))+2*fdata[0]*(-2*x1[0]*x1[0]/(a*a*a));
        grad[1]=2*fdata[1]*(-2*y*y/(b*b*b))+2*fdata[0]*(-2*x1[1]*x1[1]/(b*b*b));
        grad[2]=2*fdata[1]*(-2*z*z/(c*c*c))+2*fdata[0]*(-2*x1[2]*x1[2]/(c*c*c));
    }
    
    return fdata[0]*fdata[0]+fdata[1]*fdata[1];
}

static int DiffRadiiWPressure(sunrealtype t, N_Vector axis_radii, N_Vector f, void * user_data)
{
    sunrealtype *udata, *fdata;
    sunrealtype a,b,c;
    sunrealtype *data_a, *data_b, *data_c;
    UserSpringData data;
    
    data=(UserSpringData)user_data;
    data_a = data->point1;
    data_b = data->point2;
    data_c = data->point3;
    
    
    
    udata = N_VGetArrayPointer(axis_radii);
    fdata = N_VGetArrayPointer(f);
    
    a=udata[0];
    b=udata[1];
    c=udata[2];
    
    double p;
    double kma,mua,ka,kmb,mub,kb,kmc,muc,kc;
    kma=data_a[0];//cell.a.kmaxwell_spring;
    ka=data_a[1]; //cell.a.kspring;
    mua=data_a[2];//cell.a.mu;
    kmb=data_b[0];//cell.a.kmaxwell_spring;
    kb=data_b[1]; //cell.a.kspring;
    mub=data_b[2];//cell.a.mu;
    kmc=data_c[0];//cell.a.kmaxwell_spring;
    kc=data_c[1]; //cell.a.kspring;
    muc=data_c[2];//cell.a.mu;
    double tmp;
    tmp=ka*(b+dia)*(c+dia)/(mua*(kma+ka))+kb*(a+dia)*(c+dia)/(mub*(kmb+kb))+kc*(b+dia)*(b+dia)/(muc*(kmc+kc));
    p=ka*kma*a*(b+dia)*(c+dia)/(mua*(kma+ka))+kb*kmb*b*(a+dia)*(c+dia)/(mub*(kmb+kb))+kc*kmc*c*(b+dia)*(a+dia)/(muc*(kmc+kc));
    p=p/tmp;
    
    fdata[0]=ka*(p-kma*a)/(mua*(kma+ka));
    fdata[1]=kb*(p-kmb*b)/(mub*(kmb+kb));
    fdata[2]=kc*(p-kmc*c)/(muc*(kmc+kc));
    
    return(0);
}

